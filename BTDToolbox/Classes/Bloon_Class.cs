// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using BTDToolbox.Classes;
//
//    var bloon = Bloon.FromJson(jsonString);

namespace BTDToolbox.Classes
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Bloon
    {
        [JsonProperty("Type")]
        public string Type { get; set; }

        [JsonProperty("DrawLayer")]
        public string DrawLayer { get; set; }

        [JsonProperty("SpriteFile")]
        public string SpriteFile { get; set; }

        [JsonProperty("InitialHealth")]
        public long InitialHealth { get; set; }

        [JsonProperty("Scale")]
        public double Scale { get; set; }

        [JsonProperty("SpriteFilesAtDamageLevels")]
        public SpriteFilesAtDamageLevel[][] SpriteFilesAtDamageLevels { get; set; }

        [JsonProperty("BaseSpeed")]
        public double BaseSpeed { get; set; }

        [JsonProperty("SpeedMultiplier")]
        public double SpeedMultiplier { get; set; }

        [JsonProperty("RBE")]
        public long Rbe { get; set; }

        [JsonProperty("ChildBloons")]
        public object[] ChildBloons { get; set; }

        [JsonProperty("StatusImmunity")]
        public string[] StatusImmunity { get; set; }

        [JsonProperty("DamageImmunity")]
        public string[] DamageImmunity { get; set; }

        [JsonProperty("ApplyStatus")]
        public string[] ApplyStatus { get; set; }

        [JsonProperty("CanGoUnderground")]
        public bool CanGoUnderground { get; set; }

        [JsonProperty("RotateToPathDirection")]
        public bool RotateToPathDirection { get; set; }

        [JsonProperty("Radius")]
        public double Radius { get; set; }

        [JsonProperty("HitAddon")]
        public double HitAddon { get; set; }

        [JsonProperty("ChildEffectScale")]
        public double ChildEffectScale { get; set; }

        [JsonProperty("BloonAbility")]
        public string[] BloonAbility { get; set; }
    }

    public partial struct SpriteFilesAtDamageLevel
    {
        public long? Integer;
        public string String;

        public static implicit operator SpriteFilesAtDamageLevel(long Integer) => new SpriteFilesAtDamageLevel { Integer = Integer };
        public static implicit operator SpriteFilesAtDamageLevel(string String) => new SpriteFilesAtDamageLevel { String = String };
    }

    public partial class Bloon
    {
        public static Bloon FromJson(string json) => JsonConvert.DeserializeObject<Bloon>(json, BTDToolbox.Classes.Converter.Settings);
    }

    public static class SerializeBloon
    {
        public static string ToJson(this Bloon self) => JsonConvert.SerializeObject(self, BTDToolbox.Classes.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                SpriteFilesAtDamageLevelConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class SpriteFilesAtDamageLevelConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SpriteFilesAtDamageLevel) || t == typeof(SpriteFilesAtDamageLevel?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new SpriteFilesAtDamageLevel { Integer = integerValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new SpriteFilesAtDamageLevel { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type SpriteFilesAtDamageLevel");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (SpriteFilesAtDamageLevel)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type SpriteFilesAtDamageLevel");
        }

        public static readonly SpriteFilesAtDamageLevelConverter Singleton = new SpriteFilesAtDamageLevelConverter();
    }
}
